"""
æ•…äº‹åŠ¨ç”»å¤„ç†èŠ‚ç‚¹ - å¤åˆ»Coze Node 120984/146723
StoryAnimationProcessor: å…³é”®å¸§åŠ¨ç”»ç³»ç»Ÿ
"""

import json
import torch
from typing import List, Dict, Any, Tuple

class StoryAnimationProcessor:
    """
    å¤åˆ»Cozeå…³é”®å¸§åŠ¨ç”»åŠŸèƒ½
    - å¥‡å¶äº¤æ›¿ç¼©æ”¾åŠ¨ç”»ï¼š1.0â†”1.5
    - ä¸»è§’å¼€åœºåŠ¨ç”»ï¼š2.0â†’1.2â†’1.0
    - å¾®ç§’çº§æ—¶é—´ç²¾åº¦
    - çº¿æ€§ç¼“åŠ¨
    """
    
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "animation_timeline": ("STRING", {"multiline": True}),  # åŠ¨ç”»æ—¶é—´è½´JSON
                "video_timeline": ("STRING", {"multiline": True}),      # è§†é¢‘æ—¶é—´è½´JSON
            }
        }
    
    RETURN_TYPES = ("STRING",)
    RETURN_NAMES = ("processed_animation_data",)
    
    FUNCTION = "process_animations"
    CATEGORY = "ğŸ”¥ Shenglin/è§†é¢‘å¤„ç†"
    
    def process_animations(self, animation_timeline: str, video_timeline: str) -> Tuple[str]:
        """å¤„ç†åŠ¨ç”»æ•°æ®ï¼Œç”Ÿæˆæœ€ç»ˆçš„å…³é”®å¸§é…ç½®"""
        try:
            animation_data = json.loads(animation_timeline)
            video_data = json.loads(video_timeline)
            
            # å¤„ç†åŠ¨ç”»å…³é”®å¸§
            processed_keyframes = self._generate_keyframes(animation_data, video_data)
            
            # æ„å»ºæœ€ç»ˆåŠ¨ç”»é…ç½®
            animation_config = {
                "keyframes": processed_keyframes,
                "global_settings": {
                    "easing_function": "linear",
                    "time_unit": "microseconds",
                    "coordinate_system": "center_origin"
                },
                "tracks": self._organize_animation_tracks(processed_keyframes)
            }
            
            return (json.dumps(animation_config, ensure_ascii=False),)
            
        except Exception as e:
            print(f"AnimationProcessor error: {e}")
            return ("{}",)
    
    def _generate_keyframes(self, animation_data: List[Dict], video_data: List[Dict]) -> List[Dict]:
        """ç”Ÿæˆå…³é”®å¸§æ•°æ® - å®Œå…¨å¤åˆ»Cozeç®—æ³•"""
        keyframes = []
        
        # æŒ‰è½¨é“å¤„ç†åŠ¨ç”»
        character_segments = [v for v in video_data if v.get("track") == "character"]
        scene_segments = [v for v in video_data if v.get("track") == "scenes"]
        
        # å¤„ç†ä¸»è§’åŠ¨ç”»ï¼ˆå¤åˆ»ä¸»è§’ç‰¹æ®ŠåŠ¨ç”»ï¼š2.0â†’1.2â†’1.0ï¼‰
        for segment in character_segments:
            segment_id = f"character_{segment.get('start', 0)}"
            start_time = segment.get("start", 0)
            end_time = segment.get("end", 0)
            duration = end_time - start_time
            
            # ä¸»è§’ä¸‰æ®µå¼ç¼©æ”¾åŠ¨ç”»
            keyframes.extend([
                {
                    "segment_id": segment_id,
                    "property": "UNIFORM_SCALE",
                    "offset": 0,  # ç›¸å¯¹äºç‰‡æ®µå¼€å§‹æ—¶é—´
                    "value": 2.0,
                    "easing": "linear",
                    "absolute_time": start_time
                },
                {
                    "segment_id": segment_id,
                    "property": "UNIFORM_SCALE", 
                    "offset": 533333,  # 0.533ç§’ï¼ˆå¾®ç§’ï¼‰
                    "value": 1.2,
                    "easing": "linear",
                    "absolute_time": start_time + 533333
                },
                {
                    "segment_id": segment_id,
                    "property": "UNIFORM_SCALE",
                    "offset": duration,
                    "value": 1.0,
                    "easing": "linear", 
                    "absolute_time": end_time
                }
            ])
        
        # å¤„ç†åœºæ™¯å›¾åƒåŠ¨ç”»ï¼ˆå¥‡å¶äº¤æ›¿1.0â†”1.5ï¼‰
        for i, segment in enumerate(scene_segments):
            segment_id = f"scene_{i}"
            start_time = segment.get("start", 0)
            end_time = segment.get("end", 0)
            duration = end_time - start_time
            
            # è®¡ç®—åœºæ™¯ç´¢å¼•ï¼ˆè·³è¿‡ä¸»è§’ï¼‰
            scene_index = i
            
            # å¥‡å¶äº¤æ›¿ç¼©æ”¾æ–¹å‘
            if scene_index % 2 == 0:  # å¶æ•°åœºæ™¯ï¼š1.0â†’1.5
                start_scale = 1.0
                end_scale = 1.5
            else:  # å¥‡æ•°åœºæ™¯ï¼š1.5â†’1.0
                start_scale = 1.5
                end_scale = 1.0
            
            keyframes.extend([
                {
                    "segment_id": segment_id,
                    "property": "UNIFORM_SCALE",
                    "offset": 0,
                    "value": start_scale,
                    "easing": "linear",
                    "absolute_time": start_time
                },
                {
                    "segment_id": segment_id,
                    "property": "UNIFORM_SCALE",
                    "offset": duration,
                    "value": end_scale,
                    "easing": "linear",
                    "absolute_time": end_time
                }
            ])
        
        return keyframes
    
    def _organize_animation_tracks(self, keyframes: List[Dict]) -> Dict[str, List[Dict]]:
        """æŒ‰è½¨é“ç»„ç»‡åŠ¨ç”»æ•°æ®"""
        tracks = {}
        
        for keyframe in keyframes:
            segment_id = keyframe.get("segment_id", "unknown")
            track_name = segment_id.split("_")[0]  # character æˆ– scene
            
            if track_name not in tracks:
                tracks[track_name] = []
            
            tracks[track_name].append({
                "segment_id": segment_id,
                "property": keyframe.get("property"),
                "keyframes": self._extract_segment_keyframes(keyframes, segment_id)
            })
        
        # å»é‡
        for track_name in tracks:
            seen_segments = set()
            unique_tracks = []
            for track in tracks[track_name]:
                segment_id = track["segment_id"]
                if segment_id not in seen_segments:
                    seen_segments.add(segment_id)
                    unique_tracks.append(track)
            tracks[track_name] = unique_tracks
        
        return tracks
    
    def _extract_segment_keyframes(self, all_keyframes: List[Dict], target_segment_id: str) -> List[Dict]:
        """æå–ç‰¹å®šç‰‡æ®µçš„æ‰€æœ‰å…³é”®å¸§"""
        segment_keyframes = []
        
        for keyframe in all_keyframes:
            if keyframe.get("segment_id") == target_segment_id:
                segment_keyframes.append({
                    "time": keyframe.get("offset", 0),
                    "value": keyframe.get("value", 1.0),
                    "easing": keyframe.get("easing", "linear")
                })
        
        # æŒ‰æ—¶é—´æ’åº
        segment_keyframes.sort(key=lambda k: k["time"])
        return segment_keyframes


class StoryAnimationApplier:
    """
    åŠ¨ç”»åº”ç”¨èŠ‚ç‚¹ - å°†åŠ¨ç”»é…ç½®åº”ç”¨åˆ°è§†é¢‘è½¨é“
    """
    
    @classmethod
    def INPUT_TYPES(cls):
        return {
            "required": {
                "video_data": ("STRING", {"multiline": True}),        # è§†é¢‘æ•°æ®
                "animation_data": ("STRING", {"multiline": True}),    # åŠ¨ç”»é…ç½®
            }
        }
    
    RETURN_TYPES = ("STRING",)
    RETURN_NAMES = ("animated_video_data",)
    
    FUNCTION = "apply_animations"
    CATEGORY = "ğŸ”¥ Shenglin/è§†é¢‘å¤„ç†"
    
    def apply_animations(self, video_data: str, animation_data: str) -> Tuple[str]:
        """å°†åŠ¨ç”»é…ç½®åº”ç”¨åˆ°è§†é¢‘æ•°æ®"""
        try:
            video = json.loads(video_data)
            animations = json.loads(animation_data)
            
            # åº”ç”¨åŠ¨ç”»åˆ°è§†é¢‘è½¨é“
            animated_video = self._merge_animation_with_video(video, animations)
            
            return (json.dumps(animated_video, ensure_ascii=False),)
            
        except Exception as e:
            print(f"AnimationApplier error: {e}")
            return (video_data,)  # è¿”å›åŸå§‹è§†é¢‘æ•°æ®
    
    def _merge_animation_with_video(self, video_data: List[Dict], animation_config: Dict) -> List[Dict]:
        """å°†åŠ¨ç”»é…ç½®åˆå¹¶åˆ°è§†é¢‘æ•°æ®ä¸­"""
        animated_video = []
        keyframes = animation_config.get("keyframes", [])
        
        # ä¸ºæ¯ä¸ªè§†é¢‘ç‰‡æ®µæ·»åŠ åŠ¨ç”»ä¿¡æ¯
        for i, video_segment in enumerate(video_data):
            animated_segment = video_segment.copy()
            track = video_segment.get("track", "")
            
            # æŸ¥æ‰¾å¯¹åº”çš„åŠ¨ç”»å…³é”®å¸§
            segment_animations = []
            for keyframe in keyframes:
                segment_id = keyframe.get("segment_id", "")
                if (track == "character" and "character" in segment_id) or \
                   (track == "scenes" and "scene" in segment_id and segment_id.endswith(str(i))):
                    segment_animations.append(keyframe)
            
            # æ·»åŠ åŠ¨ç”»é…ç½®
            if segment_animations:
                animated_segment["animations"] = segment_animations
                animated_segment["has_animation"] = True
            else:
                animated_segment["has_animation"] = False
            
            animated_video.append(animated_segment)
        
        return animated_video


# ComfyUIèŠ‚ç‚¹æ˜ å°„
NODE_CLASS_MAPPINGS = {
    "StoryAnimationProcessor": StoryAnimationProcessor,
    "StoryAnimationApplier": StoryAnimationApplier,
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "StoryAnimationProcessor": "Story Animation Processor",
    "StoryAnimationApplier": "Story Animation Applier",
}